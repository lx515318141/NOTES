简历系列
本系列博客注意记录编写本次简历项目时遇到的一些问题，解决办法，以及使用到的一些工具和方法。

简历系列——滑入动画
我在本篇简历中各个模块使用了滑入的动画效果，最初使用原生实现，后因为有事会出现闪烁现象，而改为使用库。开始使用的是 scrollRevealjs 来实现滑入动画效果，使用方法如下：
引入script：
<script src="https://unpkg.com/scrollreveal"></script>
配置参数：
{
    delay: 0,
    distance: '0px',
    duration: 600,
    easing: 'cubic-bezier(0.5, 0, 0, 1)',
    interval: 0,
    opacity: 0,
    origin: 'bottom',
    rotate: {
        x: 0,
        y: 0,
        z: 0,
    },
    scale: 1,
    cleanup: false,
    container: document.documentElement,
    desktop: true,
    mobile: true,
    reset: false,
    useDelay: 'always',
    viewFactor: 0.0,
    viewOffset: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
    },
    afterReset: function (el) {},
    afterReveal: function (el) {},
    beforeReset: function (el) {},
    beforeReveal: function (el) {},
}
使用：
<h1 class="headline">
    Widget Inc.
</h1>
JavaScript：
ScrollReveal().reveal('.headline');
链式使用：
<div class="foo"> Foo </div>
<div class="bar"> Bar </div> 
JavaScript：
window.sr = ScrollReveal();
sr.reveal('.foo');
sr.reveal('.bar'); 
高级设置：
<div class="headline"> headline </div>
ScrollReveal().reveal('.headline', { wait: 200 });
或
<div class="foo"> Foo </div>
<div class="foo" id="chocolate"> Chip </div>
JavaScript：
var fooReveal = {
  delay    : 200,
  distance : '90px',
  easing   : 'ease-in-out',
  rotate   : { z: 10 },
  scale    : 1.1
};
 
window.sr = ScrollReveal()
  .reveal( '.foo', fooReveal )
  .reveal( '#chocolate', { delay: 500, scale: 0.9 } );
防止闪烁：
为了防止动画出现闪烁的现象，需要注意一下两点：
1.在HTML的头部也就是<head>中引入。
2.创建一个依赖<html class="sr">并用于visibility: hidden;隐藏元素的CSS规则集。
如：
<h1 class="headline load-hidden">
    Widget Inc.
</h1>
CSS：
html.sr .load-hidden {
    visibility: hidden;
}
JavaScript：
ScrollReveal().reveal('.headline');

但是我在使用时还是出现了问题，左右滑入的动画出现了闪烁情况，而且在第一个滑动效果执行结束之后，后面每次在执行一次滑动效果，控制台都会进行一次报错：
Cannot read property 'bounds' of undefined
此报错在我进行了多次修改和多次查找都没能找到解决办法，后只能弃用 scrollRevealjs ，改为使用 wowjs。
wowjs 这个库更加方便，他会直接绑定到HTML标签上，不需要进行过多的逻辑判断，使用放如下：
1. 首先需要页面头部引入, animate.css和wow.js, cdn地址如下:
<link href="https://cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/wow/1.1.2/wow.min.js"></script>
2. 在需要添加动画的html元素上, 新增两个类属性, 第一个为wow, 第二个为动画名如从左侧滑入slideInLeft
<div class="wow slideInLeft">从左边滑入的动画</div>
3. 添加动画控制, 主要控制四个属性:
data-wow-duration: 动画持续时间
data-wow-delay: 动画开始之前的延迟播放的时间
data-wow-offset: 元素距离底部大于此数值时,开始播放动画
data-wow-iteration: 动画重复的次数

<!--动画持续时间为2秒, 动画开始之前的延迟播放的时间为5s 元素底部距离浏览器底部400像素时开始播放动画, 动画重复次数为2次-->
<div class="wow slideInLeft" data-wow-duration="2s" data-wow-delay="5s" data-wow-offset="400" data-wow-iteration="2">从左边滑入的动画</div>

4. 在html底部添加初始化语句

<script>
    wow = new WOW(
        {
            boxClass: 'wow',      // 默认属性名
            animateClass: 'animated', // 默认触发的动画类(包含在animate css中)
            offset: 0,          // 为所有添加wow的元素设置 data-wow-delay属性 的默认值
            mobile: true,       // 是否在移动设备中开启动画
            live: true        // 持续监测页面中是否插入新的wow元素
        }
    );
    wow.init();
</script>
这样就可以使用wowjs了，下面是wowjs中各种动画的类名，也可以自己去wowjs官网首页（https://mynameismatthieu.com/WOW/），它会展示各种动画效果，通过查看他的HTML中的class也可以看到各种动画的类名。


虽然最后没有使用 scrollRevealjs 但是我很少写这种相对复杂的逻辑判断，而且为了写这个确实花了一些时间，所有还是决定写在这篇博客里，作为纪念：

{
  let view = {
    el: "body",
    init() {
      this.$el = $(this.el);
    },
    activeItem(li) {
      // 再把最近的元素加上highlight状态
      li.addClass("highlight");
      // 遍历a标签自己及其全部兄弟元素，将他们都移除highlight状态
      li.siblings().removeClass("highlight");
    },
    scrollreveal(id) {
      // console.log(id);
      if (id.indexOf(" ") === -1) {
        let up = {
          duration: 500,
          distance: "200px",
          easing: "ease-out",
          cleanup: true
        };
        ScrollReveal().destroy(`#${id}`);
        ScrollReveal().reveal(`#${id}`, up);
        this.$el.find(`#${id}`).addClass("offset");
        
      } else {
        let classList = id.split(" ");
          if (classList[0] === "even") {
            let left = {
              duration: 500,
              distance: "100px",
              easing: "ease-out",
              origin: "right",
              cleanup: true
            };
            ScrollReveal().destroy(`.${classList[1]}`, left);
            ScrollReveal().reveal(`.${classList[1]}`, left);
            this.$el.find(`.${classList[1]}`).addClass("offset");
          } else {
            let right = {
              duration: 500,
              distance: "100px",
              easing: "ease-out",
              origin: "left",
              cleanup: true
            };
            ScrollReveal().destroy(`.${classList[1]}`, right);
            ScrollReveal().reveal(`.${classList[1]}`, right);
            this.$el.find(`.${classList[1]}`).addClass("offset");
          }
        
        
      }
    },
  };
  let controller = {
    init(view) {
      this.view = view;
      this.view.init();
      this.bindEvents();
      let card = "siteAbout";
      this.view.scrollreveal(card);
    },
    bindEvents() {
      window.addEventListener('scroll', () => {
         // 找到所有有data-x的元素
         let specialTags = this.view.$el.find("[data-x]");
         // 遍历这些元素
         for (var i = 0; i < specialTags.length; i++) {
           if (specialTags[i].getBoundingClientRect().top <= $(window).height() / 2 && specialTags[i].getBoundingClientRect().top >= 0) {
             // 通过和这个ID同名的href，找到a标签，这里ID是一个变量
             let a = this.view.$el.find(`a[href="#${id}"]`);
             // 找到a标签的父级元素li
             let target = a.parent("li");
             if (target.attr('class') !== 'highlight') {
               this.view.activeItem(target);
             }
           }
           let id = specialTags[i].id;
           this.findOverBottom(specialTags[i], id);
         }
      }) 
    },
    // 寻找顶部超过窗口底部30px的元素
    findOverBottom(target, id) {
      // 找到元素顶部超出窗口底部30px以上的元素
      // $(window).height()为窗口高度；target.offsetTop元素到页面顶部距离，是个固定值；
      // window.scrollY，窗口划过的距离，即窗口顶部到页面顶部的距离
      let $height = $(window).height() - (target.offsetTop - window.scrollY);
      if ($height > 100 && target.getBoundingClientRect().bottom > 0) {
        if (id === "siteWorks") {
          let works = this.view.$el.find(`#siteWorks .workList > div`);
          for (let j = 0; j < works.length; j++) {
            let workParity = works[j].getAttribute("class");
            if(workParity.indexOf('offset') === -1){
              let $height_small =
                $(window).height() - works[j].getBoundingClientRect().top;
              if ($height_small > 100){
                this.view.scrollreveal(workParity);
              }
            }
            // let isShow_small = this.view.$el.find(`.${workParity}`).hasClass("offset");
            // console.log(this.view.$el
            //   .find(`.${workParity}`))
            // console.log(workParity);
            // console.log(isShow_small);
            // if (!isShow_small) {
            //   let $height_small =
            //     $(window).height() - works[j].getBoundingClientRect().top;
            //   if ($height_small > 100){
            //     this.view.scrollreveal(workParity);
            //   }
            // }
          }
        } else {
          let isShow = this.view.$el.find(`#${id}`).hasClass("offset");
          if (!isShow) {
            this.view.scrollreveal(id);
          }
        }
      }
    },
  };
  controller.init(view);
}